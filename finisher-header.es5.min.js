"use strict";

(function(t) {
  function getTanOffset(deg, width) {
    const radians = 0.017453 * Math.abs(deg);
    return Math.ceil(width * Math.tan(radians));
  }

  function parseHexColor(hex) {
    let c;
    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
      c = hex.substring(1).split("");
      if (c.length === 3) {
        c = [c[0], c[0], c[1], c[1], c[2], c[2]];
      }
      const colorInt = parseInt(c.join(""), 16);
      return {
        r: (colorInt >> 16) & 255,
        g: (colorInt >> 8) & 255,
        b: colorInt & 255
      };
    }
    return { r: 0, g: 0, b: 0 };
  }

  class Particle {
    constructor(color, quadrant, options) {
      this.o = options;
      this.r = parseHexColor(color);
      this.d = this.randomDirection();
      this.h = this.randomShape();
      this.s = Math.abs(this.randomRange(this.o.size));
      this.setRandomPosition(quadrant);
      this.vx = this.randomRange(this.o.speed.x) * this.randomDirection();
      this.vy = this.randomRange(this.o.speed.y) * this.randomDirection();
    }

    setRandomPosition(quadrant) {
      const area = this.getRandomArea();
      if (quadrant === 3) {
        this.x = area.x + area.halfWidth;
        this.y = area.y;
      } else if (quadrant === 2) {
        this.x = area.x;
        this.y = area.y + area.halfHeight;
      } else if (quadrant === 1) {
        this.x = area.x + area.halfWidth;
        this.y = area.y + area.halfHeight;
      } else {
        this.x = area.x;
        this.y = area.y;
      }
    }

    getRandomArea() {
      const w = this.o.c.w / 2;
      const h = this.o.c.h / 2;
      return {
        x: Math.random() * w,
        y: Math.random() * h,
        halfWidth: w,
        halfHeight: h
      };
    }

    randomRange(range) {
      return range.min === range.max ? range.min : Math.random() * (range.max - range.min) + range.min;
    }

    randomDirection() {
      return Math.random() > 0.5 ? 1 : -1;
    }

    randomShape() {
      return this.o.shapes[Math.floor(Math.random() * this.o.shapes.length)];
    }

    rgba(color, alpha) {
      return `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
    }

    animate(ctx, width, height) {
      if (this.o.size.pulse) {
        this.s += this.o.size.pulse * this.d;
        if (this.s > this.o.size.max || this.s < this.o.size.min) {
          this.d *= -1;
        }
        this.s = Math.abs(this.s);
      }

      this.x += this.vx;
      this.y += this.vy;

      if (this.x < 0 || this.x > width) this.vx *= -1;
      if (this.y < 0 || this.y > height) this.vy *= -1;

      ctx.beginPath();

      if (this.o.blending && this.o.blending !== "none") {
        ctx.globalCompositeOperation = this.o.blending;
      }

      const centerColor = this.rgba(this.r, this.o.opacity.center);
      const edgeColor = this.rgba(this.r, this.o.opacity.edge);
      const shapeRadius =
        this.h === "c" ? this.s / 2 : this.h === "t" ? 0.577 * this.s : this.h === "s" ? 0.707 * this.s : this.s;

      const gradient = ctx.createRadialGradient(this.x, this.y, 0.01, this.x, this.y, shapeRadius);
      gradient.addColorStop(0, centerColor);
      gradient.addColorStop(1, edgeColor);
      ctx.fillStyle = gradient;

      const r = this.s / 2;

      if (this.h === "c") {
        ctx.arc(this.x, this.y, Math.abs(r), 0, Math.PI * 2);
      } else if (this.h === "s") {
        const left = this.x - r;
        const right = this.x + r;
        const top = this.y - r;
        const bottom = this.y + r;
        ctx.moveTo(left, bottom);
        ctx.lineTo(right, bottom);
        ctx.lineTo(right, top);
        ctx.lineTo(left, top);
      } else if (this.h === "t") {
        const height = getTanOffset(30, r);
        const baseY = this.y + height;
        ctx.moveTo(this.x - r, baseY);
        ctx.lineTo(this.x + r, baseY);
        ctx.lineTo(this.x, this.y - 2 * height);
      }

      ctx.closePath();
      ctx.fill();
    }
  }

  class FinisherHeader {
    constructor(options) {
      this.c = document.createElement("canvas");
      this.x = this.c.getContext("2d");
      this.c.id = "finisher-canvas";
      document.body.appendChild(this.c);
      this.init(options);

      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => this.resize(), 150);
      });

      t.requestAnimationFrame(this.animate.bind(this));
    }

    resize() {
      this.o.c = {
        w: window.innerWidth,
        h: window.innerHeight
      };
      this.c.width = this.o.c.w;
      this.c.height = this.o.c.h;

      this.c.setAttribute(
        "style",
        `position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:-1;` +
        `transform:none;outline:1px solid transparent;` +
        `background-color:rgba(${this.bc.r},${this.bc.g},${this.bc.b},1);`
      );
    }

    init(options) {
      this.o = options;
      this.bc = parseHexColor(this.o.colors.background);
      this.ps = [];
      this.resize();
      this.createParticles();
    }

    createParticles() {
      let i = 0;
      this.ps = [];
      this.o.ac = t.innerWidth < 600 && this.o.count > 5 ? Math.round(this.o.count / 2) : this.o.count;

      for (let s = 0; s < this.o.ac; s++) {
        const quadrant = s % 4;
        const particle = new Particle(this.o.colors.particles[i], quadrant, this.o);
        this.ps[s] = particle;
        if (++i >= this.o.colors.particles.length) i = 0;
      }
    }

    animate() {
      t.requestAnimationFrame(this.animate.bind(this));
      this.x.clearRect(0, 0, this.o.c.w, this.o.c.h);
      for (let i = 0; i < this.o.ac; i++) {
        this.ps[i].animate(this.x, this.o.c.w, this.o.c.h);
      }
    }
  }

  t.FinisherHeader = FinisherHeader;
})(window);
